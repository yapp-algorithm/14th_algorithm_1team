# 5주차

## Red-Black Tree
- BST의 모든 노드에 Black OR Red 색을 칠한 트리이다.

## Red-Black Tree의 특징
1. 모든 Root는 Black이다.
2. 모든 Leaf는 Black이다.
3. 노드가 Red면 그 노드의 자식은 반드시 Black이다.
4. Root 노드에서 임의의 Leaf 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 간다.

## Red-Black Tree 삽입  
- (1) 이진 트리의 삽입 규칙을 따르고, 삽입한 노드는 Red로 칠한다.  
- (2)-1 삽입된 노드의 부모가 없으면 Root이므로 그 노드를 Black으로 변경 후 트리 재조정을 종료한다.  
- (2)-2 삽입된 노드의 부모 노드가 Black이면 트리 재조정이 필요없이 삽입에 성공한다.  
- (2)-3 삽입된 노드의 부모 노드가 Red이면 트리 재조정을 한다.  

## 삽입 후 트리 재조정

## Red-Black Tree 삭제

## 삭제 후 트리 재조정 

## Hash Table
- 원소가 저장될 자리가 원소의 값에 의해 결정된다
- 즉, 저장할 원소의 값으로 저장될 위치를 계산한다.
- 평균적으로 상수 시간(O(1))에 삽입, 삭제, 검색이 가능하다.
- 빠른 저장/검색에 사용하기 좋은 자료구조이다. 

### 성능
- 저장/검색 시간 복잡도 : 평균 O(1)

### 간단한 Hash Table 
- 가장 간단한 해시 테이블은 원소의 최대 값 크기의 배열이다.
- 예를 들면 1~100까지의 값을 저장한다면 크기 101인 배열에 인덱스에 값을 대응해 저장한다.
> data = 2, hashTable[data] = data;
- 공간 낭비가 심한 방식이다.

### 공간 낭비 문제 해결
- 저장할 값들을 N으로 나누었을 때 나머지가 서로 중복되지 않는다면 배열의 크기를 N으로 모든 데이터를 저장할 수 있다.
- 이때 N으로 나누었을 때 나머지가 중복된다면 제대로 동작하지 않는다.(충돌 발생)

### 충돌 문제 해결
> BasicHashTableTest 참고
- 충돌을 해결하기 위해 사용하는 자료구조가 Hash Table
- 충돌이 발생하는 경우 **저장할 인덱스의 다음 인덱스에 저장**한다.
```java
int[] data = {4, 32, 6, 17, 19, 31};
// 위의 data를 13으로 나눈다면
// index 4, 6, 6, 4, 6, 5 위치에 값이 저장된다.
```

- 4, 32 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|-|32|-|-|-|-|-|-|

- 6 저장 : 충돌 발생해서 원래 저장해야하는 index 6의 다음 위치에 저장한다. 

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|-|32|6|-|-|-|-|-|

#### 1차 군집 문제
- 위의 방식을 사용하면 데이터가 몰려 있는 근처에서 충돌 발생 확률이 높아지고, 충돌이 발생한 근처에 데이터가 쌓인다.

### 저장할 위치 계산 방법
#### Division Method
- 앞에서 사용한 저장할 값을 배열의 크기로 나눈 나머지를 이용하는 방법
- 충돌을 최대한 방지하기 위해 배열의 크기를 소수(Prime Number)로 하는 것이 좋다.

#### Multiplication Method
- 0 < N < 1인 상수를 사용해 곱셈 연산을 통해 저장할 위치를 구한다.
> 상수 N =  0.3758, 배열의 크기 32, 저장할 값이 14인 경우
1. 저장할 값 * N : 14 * 0.3758 = 73.6568
2. (1)의 결과에서 소수점 아래 자리만 꺼낸다 : 0.6568
3. (2)의 결과에서 배열의 크기를 곱한다 : 32 * 0.6568 = 21.0176
4. (3)의 결과에서 소수점 아래 자리를 버린다 : 21
- 이때 저장할 위치는 인덱스 21
- 보통 메모리 관리를 위해 2의 배수로 배열의 크기를 정한다.

### 충돌 해결 방법
#### Chaining 
- 저장할 데이터를 Linked List를 통해 저장
- 저장할 위치에 값이 많아질수록 Hash Table의 장점이 퇴색된다.
#### Open Addressing
- 그 다음칸에 저장을 시도한다.
- Linear Probing / Quadratic Probing / Double Hashing

##### Linear Probing
- 충돌이 발생한 경우, 저장할 위치에서 차례대로 다음칸에 시도하는 방식
- 위에서 언급한 1차 군집 문제 발생

##### Quadratic Probing 
> BasicHashTableTest.java Line 21 참고
- 충돌이 발생한 경우, 저장할 위치에서 1^2, 2^2, 3^2 ... 칸을 시도한다.
- Linear Probing보다 덜하지만 2차 군집 문제가 발생한다.

```java
int[] data = {4, 32, 6, 17, 19, 31};
// 위의 data를 13으로 나눈다면
// index 4, 6, 6, 4, 6, 5 위치에 값이 저장된다.
```

- 4, 32 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|-|32|-|-|-|-|-|-|

- 6 저장 : index 6에서 충돌 발생, 6 + 1^2 = 7위치에 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|-|32|6|-|-|-|-|-|

- 17 저장 : 17 % 13 = 4, index 4에서 충돌 발생, 4 + 1^2 = 5위치에 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|17|32|6|-|-|-|-|-|

- 19 저장 : 19 % 13 = 6, index 6에서 충돌 발생 
    - 6 + 1^2 = 7 위치에 저장 시도 > 충돌 발생
    - 6 + 2^2 = 10 위치에 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|17|32|6|-|-|19|-|-|

- 31 저장 : 31 % 13 = 5, index 5에서 충돌 발생 
    - 5 + 1^2 = 6 위치에 저장 시도 > 충돌 발생
    - 5 + 2^2 = 9 위치에 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|17|32|6|-|32|19|-|-|

- 1차 군집에서 충돌이 발생한 경우 모두 동일하게 4칸을 건너 뛰기 때문
- 2차 군집 문제를 해결하기 위해서는 건너 뛰는 폭이 매번 달라야 한다.

##### Double Hashing
- 충돌이 발생했을 시 건너 뛰는 폭을 매번 다르게 설정한다.
- 저장할 값에 따라 건너뛰는 폭을 다르게 계산한다. 

- 최초 저장할 위치 계산 : int startIndex = value % SIZE;
- 충돌 발생 후 건너뛸 폭 계산 : int step = value % 7 + 1;
    - 나누는 값이 소수인 것이 좋고, 배열의 크기보다 작은 것이 좋다.
    - step은 1~7 사이의 값이 나온다.
    
```java
int[] data = {4, 32, 6, 17, 19, 31};
// 위의 data를 13으로 나눈다면
// index 4, 6, 6, 4, 6, 5 위치에 값이 저장된다.
```

- 4, 32 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|-|-|-|-|4|-|32|-|-|-|-|-|-|

- 6 저장 : index 6에서 충돌 발생 
    - step = 6 % 7 + 1 = 7
    - (6 + 7) % 13 = 0 위치 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|6|-|-|-|4|-|32|-|-|-|-|-|-|

- 17 저장 : 17 % 13 = 4, index 4에서 충돌 발생 
    - step = 17 % 7 + 1 = 4
    - (4 + 4) % 13 = 8 위치 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|6|-|-|-|4|-|32|-|17|-|-|-|-|

- 19 저장 : 19 % 13 = 6, index 6에서 충돌 발생 
    - step = 19 % 7 + 1 = 6
    - (6 + 6) % 13 = 12 위치 저장

|index|0|1|2|3|4|5|6|7|8|9|10|11|12|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|value|6|-|-|-|4|-|32|-|17|-|-|-|19|

- 데이터 군집 문제가 가장 적게 발생한다.